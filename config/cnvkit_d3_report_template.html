<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=1080, initial-scale=1.0">
    <title>CNV report</title>
</head>
<body>
    <h1>CNV report</h1>

    <section>
        <h2>Chromosome view</h2>
        <p>Click and drag to zoom. Click the plot to reset zoom.</p>
        <svg id="single-chromosome"></svg>
    </section>

    <section>
        <h2>Genome view</h2>
        <p>Click a chromosome to visualise it above.</p>
        <svg id="all-chromosomes"></svg>
    </section>

    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
        const cnvData = {{ json }}

        const plotSingleChromosome = function(plotData) {
            let data = plotData;
            const height = 200;
            const width = 800;
            const margin = {
                top: 10,
                right: 30,
                bottom: 40,
                left: 50,
            };

            let leftBound = 0;
            let rightBound = data.length;

            const xScale = d3.scaleLinear()
                .domain([leftBound, rightBound])
                .range([0, width-margin.left-margin.right]);

            const yScale = d3.scaleLinear()
                .domain(d3.extent(data.regions, d => d.log2))
                .range([height-margin.top-margin.bottom, 0]);

            const xAxis = g => g
                .call(d3.axisBottom(xScale));

            const yAxis = g => g
                .call(d3.axisLeft(yScale).ticks(4));

            const svg = d3.select("#single-chromosome")
                .attr("height", height)
                .attr("width", width);

            const plotArea = svg.append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`)
                .attr("class", "plot-area");

            // Clip path for plot area
            plotArea.append("clipPath")
                .attr("id", "plot-area-clip")
                .append("rect")
                .attr("width", width - margin.left - margin.right)
                .attr("height", height - margin.top - margin.bottom);

            const regions = plotArea.append("g")
                .attr("class", "regions");

            const segments = plotArea.append("g")
                .attr("class", "segments");

            const plotRegions = function(regionData) {
                let points = regions.selectAll(".point")
                    .data(regionData);

                points.enter()
                    .append("circle")
                    .attr("class", "point")
                    .attr("cx", d => xScale(d.start))
                    .attr("cy", d => yScale(d.log2))
                    .attr("r", 2)
                    .attr("clip-path", "url(#plot-area-clip)")
                    .attr("fill", "#333")
                    .attr("fill-opacity", 0)
                    .transition()
                    .duration(500)
                    .attr("fill-opacity", 0.3);
                points.transition()
                    .duration(500)
                    .attr("cx", d => xScale(d.start))
                    .attr("cy", d => yScale(d.log2));
                points.exit()
                    .transition()
                    .attr("fill-opacity", 0)
                    .remove();
            }

            const plotSegments = function(segmentData) {
                let lineSegments = segments.selectAll(".segment")
                    .data(segmentData);

                lineSegments.enter()
                    .append("path")
                    .attr("class", "segment")
                    .attr("clip-path", "url(#plot-area-clip)")
                    .attr("d", d =>
                        `M${xScale(d.start)} ${yScale(d.log2)} L ${xScale(d.end)} ${yScale(d.log2)}`)
                    .attr("stroke", "orange")
                    .attr("stroke-width", 2)
                    .attr("stroke-opacity", 0)
                    .transition()
                    .duration(500)
                    .attr("stroke-opacity", 1)

                lineSegments.exit()
                    .transition()
                    .attr("stroke-opacity", 0)
                    .remove();

                lineSegments.transition()
                    .duration(500)
                    .attr("d", d =>
                        `M${xScale(d.start)} ${yScale(d.log2)} L ${xScale(d.end)} ${yScale(d.log2)}`);
            }

            plotRegions(data.regions);
            plotSegments(data.segments);
            let startPos = 0;
            let endPos = 0;
            let zoomStarted = false;
            plotArea.append("g")
                .attr("class", "zoom-layer")
                .append("rect")
                .attr("width", width - margin.left - margin.right)
                .attr("height", height - margin.top - margin.bottom)
                .attr("fill", "transparent")
                .on("mousedown", e => {
                    zoomStarted = true;
                    startPos = d3.pointer(e)[0];
                    endPos = startPos;
                    leftBound = xScale.invert(startPos);
                    rightBound = xScale.invert(startPos);
                    d3.select(".zoom-layer")
                        .append("rect")
                        .attr("class", "zoom-region")
                        .attr("x", startPos)
                        .attr("height", height - margin.top - margin.bottom)
                        .attr("width", 0)
                        .attr("fill", "#DDD")
                        .attr("fill-opacity", 0.3)
                        .style("pointer-events", "none");
                })
                .on("mousemove", e => {
                    if (!zoomStarted) {
                        return;
                    }
                    endPos = d3.pointer(e)[0];
                    if (startPos < endPos) {
                        // Moving left to right
                        d3.select(".zoom-region")
                            .attr("width", endPos - startPos);
                    } else {
                        // Moving right to left
                        d3.select(".zoom-region").remove();
                        d3.select(".zoom-layer").append("rect")
                            .attr("class", "zoom-region")
                            .attr("x", endPos)
                            .attr("height", height - margin.top - margin.bottom)
                            .attr("width", startPos - endPos)
                            .attr("fill", "#DDD")
                            .attr("fill-opacity", 0.3)
                            .style("pointer-events", "none");
                    }
                })
                .on("mouseup", e => {
                    zoomStarted = false;
                    d3.selectAll(".zoom-region").remove();
                    if (startPos === endPos) {
                        // Reset zoom
                        update(data);
                        return;
                    }
                    rightBound = xScale.invert(d3.pointer(e)[0]);
                    if (leftBound > rightBound) {
                        [leftBound, rightBound] = [rightBound, leftBound];
                    }
                    xScale.domain([leftBound, rightBound]);
                    let zoomRegions = data.regions.filter(d =>
                        (d.start > leftBound && d.end < rightBound)
                    );
                    let zoomSegments = data.segments.filter(d =>
                        (d.start > leftBound && d.start < rightBound) || // start within, or
                        (d.end < rightBound && d.end > leftBound) || // end within, or
                        (d.start < leftBound && d.end > rightBound) // covers whole
                    );
                    svg.transition().select(".x-axis")
                        .duration(500)
                        .call(xAxis);
                    plotRegions(zoomRegions);
                    plotSegments(zoomSegments);
                });

            svg.append("g")
                .attr("transform", `translate(${margin.left},${height-margin.bottom})`)
                .attr("class", "x-axis")
                .call(xAxis);
            svg.append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`)
                .attr("class", "y-axis")
                .call(yAxis);

            // Labels
            svg.append("text")
                .attr("transform", `translate(${width/2},${height})`)
                .attr("class", "x-label")
                .text(data.label)
                .attr("text-anchor", "middle")
                .style("font-size", "0.8rem");

            svg.append("text")
                .attr("transform", `translate(0,${margin.top+(height-margin.bottom)/2}) rotate(-90)`)
                .text("log2 ratio")
                .attr("text-anchor", "middle")
                .attr("dominant-baseline", "text-before-edge")
                .style("font-size", "0.9rem");

            const update = function(plotData) {
                data = plotData;
                xScale.domain([0, data.length]);
                yScale.domain(d3.extent(data.regions, d => d.log2));
                svg.transition().select(".x-axis")
                    .duration(500)
                    .call(xAxis);
                svg.transition().select(".y-axis")
                    .duration(500)
                    .call(yAxis);
                svg.select(".x-label").text(data.label);
                plotRegions(data.regions);
                plotSegments(data.segments);
            }

            return {
                update: update
            }
        }

        const plotAllChromosomes = function() {
            const totalLength = d3.sum(cnvData.map(d => d.length));
            const height = 200;
            const width = 800;
            const panelPadding = 0;
            const margin = {
                top: 10,
                right: 30,
                bottom: 60,
                left: 50,
            };
            const panelWidths = cnvData.map(d => (width - margin.left - margin.right) * d.length / totalLength - panelPadding);
            const panelHeight = height - margin.top - margin.bottom;

            const xScales = cnvData.map((d, i) => d3.scaleLinear()
                    .domain([0, d.length])
                    .range([0, panelWidths[i]]));

            const xAxis = (g, i) => g
                    .attr("transform", `translate(0,${panelHeight})`)
                    .call(d3.axisBottom(xScales[i]).ticks(5));

            const yAxis = g => g
                .call(d3.axisLeft(yScale).ticks(4));

            const yScale = d3.scaleLinear()
                .domain(d3.extent(d3.merge(cnvData.map(d => d.regions)), d => d.log2))
                .range([panelHeight, 0]);

            const svg = d3.select("svg#all-chromosomes")
                .attr("height", height)
                .attr("width", width)
                .attr("viewBox", [0, 0, width, height])
                .attr("style", "max-width: 100%; height: auto; height: intrinsic;");

            const panels = svg.append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`)
                .selectAll(".chromosome-plot")
                .data(cnvData)
                .enter()
                .append("g")
                .attr("data-index", (d, i) => i)
                .attr("class", "chromosome-plot")
                .attr(
                    "transform",
                    (d, i) => `translate(${i === 0 ? 0 : d3.sum(panelWidths.slice(0, i))}, 0)`
                );

            // Panel backgrounds
            panels.append("rect")
                .attr("class", "bg-rect")
                .attr("width", (d, i) => panelWidths[i])
                .attr("height", panelHeight)
                .attr("fill", "#FFF")
                .attr("stroke", "#333");

            // Baseline
            panels.append("line")
                .attr("class", "baseline")
                .attr("transform", `translate(0,${yScale(0)})`)
                .attr("x2", (d, i, g) => panelWidths[g[i].parentNode.dataset.index])
                .attr("stroke", "#000")
                .attr("stroke-opacity", 0.3)
                .attr("stroke-dasharray", 4)

            // Regions
            panels.append("g")
                .attr("class", "regions")
                .attr("data-index", (d, i) => i)
                .selectAll(".point")
                // Only plot every fifth point for performance
                .data(d => d.regions.filter((r, i) => i % 5 === 0))
                .enter()
                .append("circle")
                .attr("class", "point")
                .attr("cx", (d, i, g) => xScales[g[i].parentNode.dataset.index](d.start))
                .attr("cy", d => yScale(d.log2))
                .attr("r", 2)
                .attr("fill", "#333")
                .attr("fill-opacity", 0.3);

            // Segments
            panels.append("g")
                .attr("class", "segments")
                .attr("data-index", (d, i) => i)
                .selectAll(".segment")
                // Only draw segments that will actually be visible
                .data(d => d.segments.filter(s => s.end - s.start > totalLength/width))
                .enter()
                .append("path")
                .attr("class", "segment")
                .attr("d", (d, i, g) => {
                    let j = g[i].parentNode.dataset.index;
                    let xScale = xScales[j];
                    return `M${xScale(d.start)} ${yScale(d.log2)} L ${xScale(d.end)} ${yScale(d.log2)}`;
                })
                .attr("stroke", "orange")
                .attr("stroke-width", 2);

            // Clip path to create inner stroke
            panels.append("clipPath")
                .attr("id", (d, i) => `panel-overlay-${i}-clip`)
                .append("rect")
                .attr("width", (d, i) => panelWidths[i])
                .attr("height", panelHeight);

            panels.append("rect")
                .attr("class", "panel-overlay")
                .attr("width", (d, i) => panelWidths[i])
                .attr("height", panelHeight)
                .attr("clip-path", (d, i) => `url(#panel-overlay-${i}-clip)`)
                .attr("fill", "#000")
                .attr("fill-opacity", 0)
                .attr("stroke", "forestgreen")
                .attr("stroke-width", (d, i) => i === 0 ? 6 : 0)
                .on("mouseenter", (e, d) => {
                    panels.selectAll(".panel-overlay")
                        .attr("fill-opacity", 0);
                    d3.select(e.target)
                        .attr("fill-opacity", 0.2);
                })
                .on("mouseout", e => {
                    d3.select(e.target)
                        .attr("fill-opacity", 0);
                })
                .on("click", (e, d) => {
                    chromosomeView.update(d);
                    panels.selectAll(".panel-overlay")
                        .classed("selected", true)
                        .attr("stroke-width", 0);
                    d3.select(e.target)
                        .classed("selected", false)
                        .attr("stroke-width", 6);
                });

            // Y axis
            svg.append("g")
                .attr("transform", `translate(${margin.left}, ${margin.top})`)
                .call(yAxis);

            // Labels
            panels.append("text")
                .attr("transform", (d, i) => `translate(${panelWidths[i]/2},${panelHeight+margin.top}) rotate(-90)`)
                .text((d, i) => d.label)
                .attr("text-anchor", "end")
                .attr("dominant-baseline", "auto")
                .style("font-size", "0.8rem");

            svg.append("text")
                .attr("transform", `translate(0,${margin.top+panelHeight/2}) rotate(-90)`)
                .text("log2 ratio")
                .attr("text-anchor", "middle")
                .attr("dominant-baseline", "text-before-edge")
                .style("font-size", "0.9rem");
        };

        const chromosomeView = plotSingleChromosome(cnvData[0]);
        plotAllChromosomes();
    </script>
</body>
</html>
